---
title: Simulation With a Random Effects Model - Gage R&R as a Case Study
author: 'Riley '
date: '2020-09-09'
slug: simulation-with-a-random-effects-model-gage-r-r-as-a-case-study
categories:
  - Frequentist
  - Random Effects
  - Stats
tags:
  - R
  - Simulation
description: ''
topics: []
draft: FALSE
---

<script src="/rmarkdown-libs/htmlwidgets/htmlwidgets.js"></script>
<script src="/rmarkdown-libs/viz/viz.js"></script>
<link href="/rmarkdown-libs/DiagrammeR-styles/styles.css" rel="stylesheet" />
<script src="/rmarkdown-libs/grViz-binding/grViz.js"></script>


<p>I've heard it said that common statistical tests are just linear models.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> It turns out that Gage R&amp;R, a commonly used measurement system analysis (MSA), is no different. In this post I'll attempt to provide some background on Gage R&amp;R, describe the underlying model, and then walk through a method for simulation that can be useful for things like power analysis or visualization of uncertainty.</p>
<p>What is Gage R&amp;R?</p>
<p>When evaluating implantable medical devices it is generally necessary to perform the following types of inspection to ensure product quality:</p>
<ul>
<li>Dimensional inspection of implant features</li>
<li>Visual inspection of implant surface and component interfaces</li>
<li>Benchtop performance evaluation of implant</li>
</ul>
<p>The primary purpose of these costly and rigorous inspection processes is to screen out bad product. The ramifications of non-conforming parts reaching the field can be fatal. As such, it is important to understand any limitations of key measurement systems and, if possible, quantity their uncertainty. The primary statistical tool for this job is called Gage R&amp;R. The Gage R&amp;R attempts to quantify the total variation within a series of measurements and then describe the relative contributions of parts, operators, and repeated measurements (unexplained error). Operator error is called &quot;reproducability&quot;; unexplained error when a measurement is repeated under presumably identical conditions is called &quot;repeatability&quot;. The total variation among these components must be controlled and limited. A typical crossed structure is shown below: <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p><img src="/./img/crossed.png" width="100%" height="100%" style="display: block; margin: auto;" /></p>
<p>Gage R&amp;R training for engineers usually involves:</p>
<ul>
<li>Definitions of repeatability and reproducibility (the &quot;R&amp;R&quot;)</li>
<li>Guidance for directing Minitab to set up the experiment</li>
<li>Guidance for directing Minitab to analyze the results and provide an output</li>
<li>An acceptance criteria (with no or limited context)</li>
</ul>
<p>When I was first exposed to the material, I recall grappling with terminology and definitions, struggling with rote memorization, and having no understanding of the assumptions or limitations of the technique. Here's the piece that was never explained to me (and many other engineers):</p>
<blockquote>
<p>A Gage R&amp;R study is a random effects regression model with two random variables: operator and part. By modeling the factors as random effects and applying a few assumptions, we can access and analyze the variance associated with each component using standard ANOVA techniques.</p>
</blockquote>
<p>Specifically, the model commonly used for a crossed Gage R&amp;R is:</p>
<p><span class="math display">\[\ y_{ijk} = \mu + O_i + P_j + (PO)_{ij} + E_{(ij)k} \]</span> where:</p>
<p><span class="math inline">\(\ y_{ijk}\)</span> = a specific, individual measurement<br />
<span class="math inline">\(\ \mu\)</span> = overall mean of all the measurements<br />
<span class="math inline">\(\ O\)</span> = random variable for effect of operator. Assumed normal: <span class="math inline">\(\ O_i \sim N(0,\sigma^2_O)\)</span><br />
<span class="math inline">\(\ P\)</span> = random variable for effect of part. Assumed normal: <span class="math inline">\(\ P_i \sim N(0,\sigma^2_P)\)</span><br />
<span class="math inline">\(\ (PO)\)</span> = random variable for sample x operator interaction. Assumed normal: <span class="math inline">\(\ (PO)_{ij} \sim N(0,\sigma^2_{PO})\)</span><br />
<span class="math inline">\(\ E\)</span> = random variable for unexplained, residual error (referred to as &quot;repeatability&quot; since differences in measurements taken under identical conditions are mapped here). <span class="math inline">\(\ E_{(ij)k} \sim N(0,\sigma^2_{E})\)</span></p>
<p>This is really cool! - Understanding the model unlocks the insight behind the method and casts a bright light on the assumptions. It puts a seemingly obscure, memorized technique into a familiar regression framework. It also facilitates simulation.</p>
<p>Why is it a random effects model? What is a random effects model? The answer to that question is actually tricky (and beyond the scope of this post) but there is some good information <a href="http://www.stat.columbia.edu/~gelman/research/published/banova7.pdf">here</a> for those who want to dive deeper. <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> While not a formal definition, it may be sufficient to know that random effects are estimated with partial pooling while others are not.</p>
<p>In this post I will attempt to show how to use the lme4 to simulate outcomes using a random effects model like the one listed above and then repeat many such simulations to gain understanding of uncertainty and sensitivity in the underlying experiment.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> Fun!</p>
<p>Here are the libraries we'll use.</p>
<pre class="r"><code>library(lme4)
library(tidyverse)
library(knitr)
library(here)
library(broom.mixed)
library(tidybayes)
library(DiagrammeR)</code></pre>
<div id="simulating-one-outcome-of-a-gage-rr-experiment" class="section level2">
<h2>Simulating One Outcome of a Gage R&amp;R Experiment</h2>
<p>Before we worry about running a bunch of simulations, let's just figure out how to run one instance of a Gage R&amp;R. There are some really good tutorials out there for simulating outcomes from random and mixed effects models.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> It ends up being a little bit tricky because the parameters that you select need to combine within the design matrix in a certain way such that an analysis of the simulated outcomes can recover the specified parameters. If you are good at matrix math you can do this manually. I am not very good at matrix mat - but fortunately Robert Long on Cross Validated<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> showed me a really cool little hack for figuring out the form of the Design Matrix Z and using it for simulation. Basically, we will first set up a dummy experiment with the desired number of parts, operators, and measurements and then use lme4 to extract Z and store it. Then we can set up a vector of all our simulated random effects and combine them with matrix multiplication to build the simulated observation. It sounds tricky but it's surprisingly simple! in summary, here is the plan:</p>
<p><div id="htmlwidget-1" style="width:100%;height:500px;" class="grViz html-widget"></div>
<script type="application/json" data-for="htmlwidget-1">{"x":{"diagram":"digraph flowchart {\n      # node definitions with substituted label text\n      node [fontname = Helvetica, shape = rectangle, fillcolor = yellow]        \n      tab1 [label = \"Step 1: Setup a dummy experiment\"]\n      tab2 [label = \"Step 2: Fit a model to the dummy data\"]\n      tab3 [label = \"Step 3: Extract and store the Design Matrix Z from the dummy model\"]\n      tab4 [label = \"Step 4: Simulate random effects using rnorm or similar\"]\n      tab5 [label = \"Step 5: Multiply Z by random effects vector\"]\n      tab6 [label = \"Step 6: Combine result with simulated residual error to generate simulated observations\"]\n      tab7 [label = \"Step 7: Fit a model to the simulated obervations\"]\n      # edge definitions with the node IDs\n      tab1 -> tab2 -> tab3 -> tab4 -> tab5 -> tab6 -> tab7;\n      }\n      ","config":{"engine":"dot","options":null}},"evals":[],"jsHooks":[]}</script> The good news is that none of the above steps are very hard, even if they look unfamiliar. Let's go through it.</p>
</div>
<div id="step-1-set-up-a-dummy-experiment" class="section level2">
<h2>Step 1: Set up a dummy experiment</h2>
<p>I call this a dummy experiment because while it will have the proper number of operators/parts/replicates, we'll just drop in some dummy data as the observations. The goal here is to allow lme4 to create the structure of the experiment (the design matrix) which we can use later to get the real simulated observations.</p>
<p>First, we specify the number of parts, operators, and measurements we want the experiment be comprised of. 10, 3, and 2, respectively, is a common experimental setup in industry and we use it here.</p>
<pre class="r"><code>n_part &lt;- 10 # number of parts
n_oper &lt;- 3 # number of opers
n_measurements &lt;- 2 # number of replications</code></pre>
<p>Now assign names to each part, operator, trial and determine how many observations will be in the study: n_matrix.</p>
<pre class="r"><code># assign names to each part, operator, trial
part &lt;- str_glue(&quot;part_{1:n_part}&quot;) %&gt;% as_factor()
operator &lt;- str_glue(&quot;oper_{1:n_oper}&quot;) %&gt;% as_factor()
measurement &lt;- str_glue(&quot;measurment_{1:n_measurements}&quot;) %&gt;% as_factor()

n_matrix &lt;- n_part * n_oper * n_measurements # number of observations in the study

n_matrix</code></pre>
<pre><code>## [1] 60</code></pre>
<p>Now we use crossing() to build the full set of experimental conditions. Dummy observations are created for each setting and assigned to a new col: &quot;measurement&quot;. Overall mean of 10 is chosen arbitrarily and isn't important. Note: we are creating observations(measurements) here but have not concerned ourselves with specifying the parameters of any random variables yet. We just need a placeholder in the measurement column.</p>
<pre class="r"><code># generate experimental design and outcomes for dummy study
grr_dummy_tbl &lt;- crossing(part, operator, measurement) %&gt;%
  mutate(measurement = 10 + rnorm(n_matrix))

grr_dummy_tbl %&gt;%
  head(7) %&gt;%
  kable(align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">part</th>
<th align="center">operator</th>
<th align="center">measurement</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">part_1</td>
<td align="center">oper_1</td>
<td align="center">9.658576</td>
</tr>
<tr class="even">
<td align="center">part_1</td>
<td align="center">oper_1</td>
<td align="center">10.897126</td>
</tr>
<tr class="odd">
<td align="center">part_1</td>
<td align="center">oper_2</td>
<td align="center">8.919642</td>
</tr>
<tr class="even">
<td align="center">part_1</td>
<td align="center">oper_2</td>
<td align="center">10.442563</td>
</tr>
<tr class="odd">
<td align="center">part_1</td>
<td align="center">oper_3</td>
<td align="center">10.706771</td>
</tr>
<tr class="even">
<td align="center">part_1</td>
<td align="center">oper_3</td>
<td align="center">9.217397</td>
</tr>
<tr class="odd">
<td align="center">part_2</td>
<td align="center">oper_1</td>
<td align="center">10.869825</td>
</tr>
</tbody>
</table>
<pre class="r"><code>grr_dummy_tbl %&gt;%
  tail(7) %&gt;%
  kable(align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">part</th>
<th align="center">operator</th>
<th align="center">measurement</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">part_9</td>
<td align="center">oper_3</td>
<td align="center">9.770813</td>
</tr>
<tr class="even">
<td align="center">part_10</td>
<td align="center">oper_1</td>
<td align="center">9.862329</td>
</tr>
<tr class="odd">
<td align="center">part_10</td>
<td align="center">oper_1</td>
<td align="center">9.044466</td>
</tr>
<tr class="even">
<td align="center">part_10</td>
<td align="center">oper_2</td>
<td align="center">8.769776</td>
</tr>
<tr class="odd">
<td align="center">part_10</td>
<td align="center">oper_2</td>
<td align="center">11.515547</td>
</tr>
<tr class="even">
<td align="center">part_10</td>
<td align="center">oper_3</td>
<td align="center">8.722872</td>
</tr>
<tr class="odd">
<td align="center">part_10</td>
<td align="center">oper_3</td>
<td align="center">10.689403</td>
</tr>
</tbody>
</table>
</div>
<div id="step-2-fit-a-model-to-the-dummy-data" class="section level2">
<h2>Step 2: Fit a model to the dummy data</h2>
<p>Now we fit a model to the dummy data. The summary isn't important - we just want access to the structure which we will get in the next step.</p>
<pre class="r"><code># fit model for dummy study
m1 &lt;- lmer(measurement ~ (1 | part) + (1 | operator) + (1 | part:operator), data = grr_dummy_tbl)</code></pre>
</div>
<div id="step-3-extract-and-store-the-design-matrix-z-from-the-dummy-model" class="section level2">
<h2>Step 3: Extract and store the Design Matrix Z from the dummy model</h2>
<p>Here's the little hack: Use getME() to pull the design matrix Z from the dummy model. Alternately, you can use lFormula() but you will have to fish the matrix out and transpose it which is not as intuitive to me.</p>
<pre class="r"><code># extract design matrix Z from dummy model
design_matrix_Z &lt;- getME(m1, &quot;Z&quot;) %&gt;% as.matrix()

design_matrix_Z %&gt;% head(1)</code></pre>
<pre><code>##   part_1:oper_1 part_1:oper_2 part_1:oper_3 part_2:oper_1 part_2:oper_2
## 1             1             0             0             0             0
##   part_2:oper_3 part_3:oper_1 part_3:oper_2 part_3:oper_3 part_4:oper_1
## 1             0             0             0             0             0
##   part_4:oper_2 part_4:oper_3 part_5:oper_1 part_5:oper_2 part_5:oper_3
## 1             0             0             0             0             0
##   part_6:oper_1 part_6:oper_2 part_6:oper_3 part_7:oper_1 part_7:oper_2
## 1             0             0             0             0             0
##   part_7:oper_3 part_8:oper_1 part_8:oper_2 part_8:oper_3 part_9:oper_1
## 1             0             0             0             0             0
##   part_9:oper_2 part_9:oper_3 part_10:oper_1 part_10:oper_2 part_10:oper_3
## 1             0             0              0              0              0
##   part_1 part_2 part_3 part_4 part_5 part_6 part_7 part_8 part_9 part_10
## 1      1      0      0      0      0      0      0      0      0       0
##   oper_1 oper_2 oper_3
## 1      1      0      0</code></pre>
<pre class="r"><code># alternate method:
# mylF &lt;- lFormula(m1, data = grr_dummy_tbl) # Process the formula against the data
# design_matrix_Z &lt;- mylF$reTrms$Zt %&gt;% as.matrix() %&gt;% t()  # Extract the Z matrix</code></pre>
<p>So much easier than constructing this matrix yourself! (at least for me - it's been a while now since I took linear algebra course and tensor notation was always challenging).</p>
</div>
<div id="step-4-simulate-random-effects-using-rnorm-or-similar" class="section level2">
<h2>Step 4: Simulate random effects using rnorm or similar</h2>
<p>With the matrix Z in hand we can get get rid of the dummy model and get down to business with specifying and simulating our random effects. Specify standard deviations for each effect and simulate using rnorm(). 1, 2, 9, and 4 are the parameters that we will compare our estimates against later on.</p>
<pre class="r"><code>set.seed(0118)
int_intercepts_sd &lt;- 1 # standard dev of interaction random effects
oper_intercepts_sd &lt;- 2 # standard dev of operator random effects
part_intercepts_sd &lt;- 9 # standard dev of operator random effects
random_error_repeatability &lt;- 4 # standard dev of random error (repeatability)

# simulate random effects using input params for sd
int_intercepts &lt;- rnorm(n = n_part * n_oper, mean = 0, sd = int_intercepts_sd)
oper_intercepts &lt;- rnorm(n = n_oper, mean = 0, sd = oper_intercepts_sd)
part_intercepts &lt;- rnorm(n = n_part, mean = 0, sd = part_intercepts_sd)</code></pre>
<p>Combine all the random effects into a vector. Order does matter here - see comment below.</p>
<pre class="r"><code># vector of all random effect intercepts (order matters here: ineraction, part, oper if n_oper &lt; n_part, else swith part and oper)

random_effects_intercepts &lt;- c(int_intercepts, part_intercepts, oper_intercepts)
random_effects_intercepts</code></pre>
<pre><code>##  [1]  -1.676079782   0.167651720  -0.008545182   0.296888139  -1.706489201
##  [6]  -1.049094451  -0.102206749   0.682492401  -0.511117703   0.487346673
## [11]  -1.345812057   0.527128496   0.686104071  -0.221484626   0.532399538
## [16]   0.597393622   0.831437918   0.735023009   0.830043214   0.769163682
## [21]   1.830416344   0.182049999   1.018859437   0.844012288   0.575312043
## [26]   0.006855854  -0.231251230   0.205834471   0.250942908  -1.575663200
## [31]  19.280822421  10.499576059  -3.997253469  -7.111499870   6.986996777
## [36]  -4.861684848 -13.031232590  14.723410605  16.967969396  22.293922487
## [41]  -1.345816596  -3.905496830  -4.061788248</code></pre>
</div>
<div id="step-5-multiply-z-by-random-effects-vector" class="section level2">
<h2>Step 5: Multiply Z by random effects vector</h2>
</div>
<div id="step-6-combine-result-with-simulated-residual-error-to-generate-simulated-observations" class="section level2">
<h2>Step 6: Combine result with simulated residual error to generate simulated observations</h2>
<p>We'll do steps 5 and 6 together here: multiply the design matrix Z by the vector of random effects intercepts and then add in a residual error. %*% is the matrix multiplication operator. Again - the overall mean of 10 is arbitrary and does not change the analysis.</p>
<pre class="r"><code># create observations (add in repeatability random error to each term). %*% is matrix multiplication
grr_sim_tbl &lt;- grr_dummy_tbl %&gt;%
  mutate(measurement = 10 + design_matrix_Z %*% random_effects_intercepts + rnorm(
    n = nrow(grr_dummy_tbl),
    mean = 0,
    sd = random_error_repeatability
  ))

grr_sim_tbl %&gt;%
  head(10) %&gt;%
  kable(align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">part</th>
<th align="center">operator</th>
<th align="center">measurement</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">part_1</td>
<td align="center">oper_1</td>
<td align="center">25.335155</td>
</tr>
<tr class="even">
<td align="center">part_1</td>
<td align="center">oper_1</td>
<td align="center">28.246367</td>
</tr>
<tr class="odd">
<td align="center">part_1</td>
<td align="center">oper_2</td>
<td align="center">15.799074</td>
</tr>
<tr class="even">
<td align="center">part_1</td>
<td align="center">oper_2</td>
<td align="center">23.051405</td>
</tr>
<tr class="odd">
<td align="center">part_1</td>
<td align="center">oper_3</td>
<td align="center">22.791039</td>
</tr>
<tr class="even">
<td align="center">part_1</td>
<td align="center">oper_3</td>
<td align="center">17.986515</td>
</tr>
<tr class="odd">
<td align="center">part_2</td>
<td align="center">oper_1</td>
<td align="center">19.378715</td>
</tr>
<tr class="even">
<td align="center">part_2</td>
<td align="center">oper_1</td>
<td align="center">14.934401</td>
</tr>
<tr class="odd">
<td align="center">part_2</td>
<td align="center">oper_2</td>
<td align="center">9.109815</td>
</tr>
<tr class="even">
<td align="center">part_2</td>
<td align="center">oper_2</td>
<td align="center">14.250238</td>
</tr>
</tbody>
</table>
</div>
<div id="step-7-fit-a-model-to-the-simulated-obervations" class="section level2">
<h2>Step 7: Fit a model to the simulated obervations</h2>
<p>Once again we fit a model, but this time the observations are meaningful because we constructed them properly using the design matrix Z. broom.mixed::tidy() is able to bring the results into tibble format where we can clean a bit and view the variance contribution of each variable. This gives a point estimate of variance sd for the random effects that can be compared against the referent inputs.</p>
<pre class="r"><code># fit a model to the simulated dataset
sim_m_fit &lt;- lmer(measurement ~ (1 | part) + (1 | operator) + (1 | part:operator), data = grr_sim_tbl)

# tibble of results for a single simulation
one_grr_result_tbl &lt;-
  broom.mixed::tidy(sim_m_fit, effects = &quot;ran_pars&quot;) %&gt;%
  rename(
    st_dev_estimate = estimate,
    variable = group
  ) %&gt;%
  mutate(
    variance_estimate = st_dev_estimate^2,
    sim_number = 1
  ) %&gt;%
  select(sim_number, variable, st_dev_estimate, variance_estimate)

one_grr_result_tbl %&gt;% kable(align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">sim_number</th>
<th align="center">variable</th>
<th align="center">st_dev_estimate</th>
<th align="center">variance_estimate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">part:operator</td>
<td align="center">0.4484307</td>
<td align="center">0.2010901</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">part</td>
<td align="center">11.4718335</td>
<td align="center">131.6029628</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">operator</td>
<td align="center">1.6062900</td>
<td align="center">2.5801677</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">Residual</td>
<td align="center">3.9540576</td>
<td align="center">15.6345714</td>
</tr>
</tbody>
</table>
<p>Recall that the true parameters for sd were 1, 9, 2, and 4. These estimates aren't dead on but we don't really understand how much uncertainty is involved with our estimate. We'll return to that in a moment.</p>
<p>One common performance metric for a Gage R&amp;R is %tolerance: 6 (or some other constant) times the sum of the measurement system variance (everything except for part variance) divided by the tolerance span for this particular measurement.</p>
<p><span class="math display">\[\ Percent\space Tolerance = 6 \times (\hat\sigma_E^2 + \hat\sigma_O^2 + \hat\sigma_{PO}^2)\space/\space Tolerance \]</span></p>
<p>It is common for the tolerance span to be approximately 6 x the standard deviation of the parts population. Let's make that assumption here so we can estimate the percent tolerance from the data and compare to the true value. Once the simulation is established, the standard deviation of the parts can be adjusted to see how the percent tolerance changes for a given sd of operators, part:operator interaction, and residual.</p>
<pre class="r"><code>one_grr_tol_outcome_tbl &lt;- one_grr_result_tbl %&gt;%
  filter(variable != &quot;part&quot;) %&gt;%
  group_by(sim_number) %&gt;%
  summarize(grr_variance_est = sum(variance_estimate)) %&gt;%
  mutate(true_tol_pct = scales::percent((int_intercepts_sd^2 + oper_intercepts_sd^2 + random_error_repeatability^2) / part_intercepts_sd)) %&gt;%
  rowwise() %&gt;%
  mutate(est_tol_pct = scales::percent(grr_variance_est / part_intercepts_sd))

one_grr_tol_outcome_tbl %&gt;% kable(align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">sim_number</th>
<th align="center">grr_variance_est</th>
<th align="center">true_tol_pct</th>
<th align="center">est_tol_pct</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">18.41583</td>
<td align="center">233%</td>
<td align="center">205%</td>
</tr>
</tbody>
</table>
<p>Since 205% is &gt; 30%, this experiment would &quot;fail&quot; and the measurement system would not be validated. Not really interesting since we just chose arbitrary numbers but the estimate is reasonably close to the true value which is more important. It would be good to know that if we repeated the simulation a lot of times, the average estimate will converge near the true value.</p>
</div>
<div id="scale-simulation-with-a-function" class="section level1">
<h1>Scale Simulation with a Function</h1>
<p>If want to simulate a lot of Gage R&amp;R's, we can take all the code chunks above and wrap them in a function and then just swap out the values we want to adjust for argument in the function. The function below will take:</p>
<ul>
<li>n = number of simulations</li>
<li>np = number of parts</li>
<li>no = number of operators</li>
<li>nm = number of measurements per operator</li>
<li>iisd = interaction intercepts standard deviation</li>
<li>oisd = operator intercepts standard deviation</li>
<li>pisd = part intercepts standard deviation</li>
<li>rer = random error (repeatability) standard deviation</li>
</ul>
<p>I'm pretty sure this operation could be done faster and cleaner than the code shown below, but I like how the code maps to the single case simulation above for easy human readability. For this reason, I use a for loop instead of some map() variant.</p>
<pre class="r"><code>grr_fct &lt;- function(n, np, no, nm, iisd, oisd, pisd, rer) {
  all_grr_results_tbl &lt;- NULL # tibble to hold results
  n_sims &lt;- n # number of simulations
  n_part &lt;- np # number of parts
  n_oper &lt;- no # number of opers
  n_measurements &lt;- nm # number of replications

  int_intercepts_sd &lt;- iisd # standard dev of interaction random effects
  oper_intercepts_sd &lt;- oisd # standard dev of operator random effects
  part_intercepts_sd &lt;- pisd # standard dev of operator random effects
  random_error_repeatability &lt;- rer # standard dev of random error (repeatability)

  # assign names to each per, operator, trial
  part &lt;- str_glue(&quot;part_{1:n_part}&quot;) %&gt;% as_factor()
  operator &lt;- str_glue(&quot;oper_{1:n_oper}&quot;) %&gt;% as_factor()
  measurement &lt;- str_glue(&quot;measurment_{1:n_measurements}&quot;) %&gt;% as_factor()

  n_matrix &lt;- n_part * n_oper * n_measurements # number of observations in the study

  for (i in 1:n) {

    # generate experimental designa and outcomes for dummy study
    grr_dummy_tbl &lt;- crossing(part, operator, measurement) %&gt;%
      mutate(measurement = 10 + rnorm(n_matrix))

    # fit model for dummy study
    m1 &lt;- lmer(measurement ~ (1 | part) + (1 | operator) + (1 | part:operator), data = grr_dummy_tbl)

    # extract design matrix Z from dummy model
    design_matrix_Z &lt;- getME(m1, &quot;Z&quot;) %&gt;% as.matrix()

    # simulate random effects using input params for sd
    int_intercepts &lt;- rnorm(n = n_part * n_oper, mean = 0, sd = int_intercepts_sd)
    oper_intercepts &lt;- rnorm(n = n_oper, mean = 0, sd = oper_intercepts_sd)
    part_intercepts &lt;- rnorm(n = n_part, mean = 0, sd = part_intercepts_sd)

    # vector of all random effect intercepts (order matters here: ineraction, oper, part)
    random_effects_intercepts &lt;- c(int_intercepts, part_intercepts, oper_intercepts)

    # create observations (add in repeatability random error to each term). %*% is matrix multiplication
    grr_sim_tbl &lt;- grr_dummy_tbl %&gt;%
      mutate(measurement = 10 + design_matrix_Z %*% random_effects_intercepts + rnorm(
        n = nrow(grr_dummy_tbl),
        mean = 0,
        sd = random_error_repeatability
      ))

    # fit a model to the simulated dataset
    sim_m_fit &lt;- lmer(measurement ~ (1 | part) + (1 | operator) + (1 | part:operator), data = grr_sim_tbl)

    # tibble of results for a single simulation
    one_grr_result_tbl &lt;-
      broom.mixed::tidy(sim_m_fit, effects = &quot;ran_pars&quot;) %&gt;%
      rename(
        st_dev_estimate = estimate,
        variable = group
      ) %&gt;%
      mutate(
        variance_estimate = st_dev_estimate^2,
        sim_number = i
      ) %&gt;%
      select(sim_number, variable, st_dev_estimate, variance_estimate)

    # append this recent simulation to the others
    all_grr_results_tbl &lt;- bind_rows(all_grr_results_tbl, one_grr_result_tbl)
  }
  return(all_grr_results_tbl)
}</code></pre>
<p>Test the function by calling it once, asking for just 3 simulations:</p>
<pre class="r"><code>fcn_test_tbl &lt;- grr_fct(n = 3, np = 10, no = 3, nm = 2, iisd = 4, oisd = 3, pisd = 2, rer = 1)

fcn_test_tbl %&gt;% kable(align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">sim_number</th>
<th align="center">variable</th>
<th align="center">st_dev_estimate</th>
<th align="center">variance_estimate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">part:operator</td>
<td align="center">3.4214284</td>
<td align="center">11.7061726</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">part</td>
<td align="center">2.1832882</td>
<td align="center">4.7667475</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">operator</td>
<td align="center">1.6916881</td>
<td align="center">2.8618086</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">Residual</td>
<td align="center">1.0355244</td>
<td align="center">1.0723107</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="center">part:operator</td>
<td align="center">4.7726138</td>
<td align="center">22.7778428</td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center">part</td>
<td align="center">0.0010317</td>
<td align="center">0.0000011</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="center">operator</td>
<td align="center">0.0000000</td>
<td align="center">0.0000000</td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center">Residual</td>
<td align="center">1.0763577</td>
<td align="center">1.1585460</td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center">part:operator</td>
<td align="center">4.0704728</td>
<td align="center">16.5687489</td>
</tr>
<tr class="even">
<td align="center">3</td>
<td align="center">part</td>
<td align="center">1.2724219</td>
<td align="center">1.6190574</td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center">operator</td>
<td align="center">3.2107023</td>
<td align="center">10.3086089</td>
</tr>
<tr class="even">
<td align="center">3</td>
<td align="center">Residual</td>
<td align="center">0.9178515</td>
<td align="center">0.8424514</td>
</tr>
</tbody>
</table>
<p>Everything is looking good! The results from n=3 simulations have completed and are summarized nicely in the results tbl.</p>
<p>Rather than manually call the function and input the arguments every time, we can populate a &quot;setup tbl&quot; that contains all the arguments that we will want to look at. Within the tbl we can look at anything we want. For example, we might want several different values for number of operators, or several different levels of standard deviation for one of the random effects. In this case, I was interested in several different magnitudes of standard deviation for the population of parts because the part sd is used as a surrogate for the tolerance percentage calculation as shown above. This is a useful simulation because we should be able to visualize:</p>
<ul>
<li>Does the average of the simulation converge near the true value for percent tolerance?</li>
<li>How often might individual estimates of pct tol &quot;fail&quot; (&gt; 30%) when the average of the estimates passes (&lt; 30%)?</li>
</ul>
<p>Fist, the setup_tbl. Note: the variance of the random variables for operator, repeatability(residual), and part:operator interaction are all held at 1 while the variance for part is increased.</p>
<pre class="r"><code>sim_setup_tbl &lt;- tibble(
  n_sims = 200,
  n_part = 10,
  n_oper = 3,
  n_meas = 2,
  int_sd = 1,
  oper_sd = 1,
  #  part_var = 1,
  part_var = c(2^(0:10)),
  repeatab_sd = 1
) %&gt;%
  mutate(
    row_id = row_number()
  ) %&gt;%
  rowwise() %&gt;%
  mutate(part_sd = part_var^.5) %&gt;%
  mutate(tol_pct_true = 6 * (int_sd^2 + oper_sd^2 + repeatab_sd^2) / (6 * part_sd))

sim_setup_tbl %&gt;% kable(align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">n_sims</th>
<th align="center">n_part</th>
<th align="center">n_oper</th>
<th align="center">n_meas</th>
<th align="center">int_sd</th>
<th align="center">oper_sd</th>
<th align="center">part_var</th>
<th align="center">repeatab_sd</th>
<th align="center">row_id</th>
<th align="center">part_sd</th>
<th align="center">tol_pct_true</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1.000000</td>
<td align="center">3.0000000</td>
</tr>
<tr class="even">
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1.414214</td>
<td align="center">2.1213203</td>
</tr>
<tr class="odd">
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">2.000000</td>
<td align="center">1.5000000</td>
</tr>
<tr class="even">
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">8</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">2.828427</td>
<td align="center">1.0606602</td>
</tr>
<tr class="odd">
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">16</td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">4.000000</td>
<td align="center">0.7500000</td>
</tr>
<tr class="even">
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">32</td>
<td align="center">1</td>
<td align="center">6</td>
<td align="center">5.656854</td>
<td align="center">0.5303301</td>
</tr>
<tr class="odd">
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">64</td>
<td align="center">1</td>
<td align="center">7</td>
<td align="center">8.000000</td>
<td align="center">0.3750000</td>
</tr>
<tr class="even">
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">128</td>
<td align="center">1</td>
<td align="center">8</td>
<td align="center">11.313709</td>
<td align="center">0.2651650</td>
</tr>
<tr class="odd">
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">256</td>
<td align="center">1</td>
<td align="center">9</td>
<td align="center">16.000000</td>
<td align="center">0.1875000</td>
</tr>
<tr class="even">
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">512</td>
<td align="center">1</td>
<td align="center">10</td>
<td align="center">22.627417</td>
<td align="center">0.1325825</td>
</tr>
<tr class="odd">
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1024</td>
<td align="center">1</td>
<td align="center">11</td>
<td align="center">32.000000</td>
<td align="center">0.0937500</td>
</tr>
</tbody>
</table>
<p>The following code executes many simulations, one for each set of arguments from the rows above. Each simulation from each row results in a tibble of outcomes which is stored in a list column and the unnested later on to make a big tibble. I'm not actually 100% sure that you need rowwise() here - it works fine with it in place and makes sense to me that you would group by rows here but I'm still trying to figure out what row-based workflow works best for me. I believe there are other good options that use the map family.</p>
<pre class="r"><code>set.seed(0118)

#commented out because this takes a while to run

# sim_outcomes_tbl &lt;- sim_setup_tbl %&gt;%
#   rowwise() %&gt;% # may not be needed
#   mutate(sim_outcomes = list(grr_fct(n = n_sims, np = n_part, no = n_oper, nm = n_meas, iisd = int_sd, oisd = oper_sd, pisd = part_sd, rer = repeatab_sd))) %&gt;%
#   select(sim_outcomes, everything()) %&gt;%
#   unnest(cols = c(sim_outcomes)) %&gt;%
#   mutate_if(is.character, as_factor)</code></pre>
<pre class="r"><code>sim_outcomes_tbl %&gt;%
  select(sim_number, variable, st_dev_estimate, n_sims, n_part, n_meas, int_sd, oper_sd, repeatab_sd, part_sd) %&gt;%
  head(12) %&gt;%
  kable(align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">sim_number</th>
<th align="center">variable</th>
<th align="center">st_dev_estimate</th>
<th align="center">n_sims</th>
<th align="center">n_part</th>
<th align="center">n_meas</th>
<th align="center">int_sd</th>
<th align="center">oper_sd</th>
<th align="center">repeatab_sd</th>
<th align="center">part_sd</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">part:operator</td>
<td align="center">0.5511238</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">part</td>
<td align="center">0.8165034</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">operator</td>
<td align="center">0.5369841</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">Residual</td>
<td align="center">1.0638795</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="center">part:operator</td>
<td align="center">0.8046511</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center">part</td>
<td align="center">1.1717770</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="center">operator</td>
<td align="center">0.9339445</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center">Residual</td>
<td align="center">0.9631640</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center">part:operator</td>
<td align="center">1.0850250</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">3</td>
<td align="center">part</td>
<td align="center">0.0031052</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center">operator</td>
<td align="center">1.7490297</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">3</td>
<td align="center">Residual</td>
<td align="center">0.9284068</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<p>We might look at the results for a single group of arguments in the setup tbl by filtering to a specific row (I choose row 4 arbitrarily here). Note that &quot;row_id&quot; is a little misleading here because the data has been reshaped. Filtering fora specific row_id returns results from the set of simulations from a single row of parameters in the original setup_tbl. Here we look at the results form row_4 where the true part sd was 2.82 while the sd for operator, Residual, and interaction were all 1.)</p>
<pre class="r"><code>a &lt;- sim_outcomes_tbl %&gt;%
  filter(row_id == 4) %&gt;%
  filter(st_dev_estimate &gt; .001) %&gt;%
  ggplot(aes(x = variable, y = st_dev_estimate)) +
  geom_jitter(width = .05, alpha = .5, size = .6) +
  geom_hline(yintercept = 1, lty = 2, color = &quot;#2c3e50&quot;) +
  geom_hline(yintercept = 2.8428472, lty = 2, color = &quot;#2c3e50&quot;) +
  #    stat_summary(fun.y= mean, fun.ymin=mean, fun.ymax=mean, geom=&quot;crossbar&quot;, width=0.2, color=&quot;red&quot;) +
  stat_halfeye(aes(fill = variable), point_interval = mean_qi, alpha = .7, position = position_nudge(x = .15)) +
  labs(
    title = &quot;Gage R&amp;R - Estimates for Standard Deviation of Different Components of Variation&quot;,
    subtitle = str_glue(&quot;Settings: {sim_outcomes_tbl$n_part[1]} Parts, {sim_outcomes_tbl$n_oper[1]} Operators, {sim_outcomes_tbl$n_meas[1]} Measurements&quot;),
    x = &quot;&quot;,
    y = &quot;Standard Deviation Estimate&quot;,
    caption = &quot;dotted line marks true population standard dev\n Interval marks median, .66 quantile, .95 quantile&quot;
  ) +
  theme(legend.position = &quot;none&quot;) +
  scale_fill_viridis_d(option = &quot;c&quot;, end = .7)

a</code></pre>
<p><img src="/post/2020-09-09-simulation-with-a-random-effects-model-gage-r-r-as-a-case-study_files/figure-html/unnamed-chunk-20-1.png" width="100%" height="500px" /></p>
<p>Looks good! The averages of the set of simulations is converging nicely and we get a good feel for how much uncertainty would be expected for a single trial.</p>
<p>Now to plot multiple simulations. A bit of data preparation is required to plot the true values on the same canvas as the individual sims. There is probably a cleaner way to do this directly within ggplot - but the way I do it here is to pull the values from the rows down into tidy format with pivot_longer and then do some grouping and joining.</p>
<pre class="r"><code>sim_tbl &lt;- sim_outcomes_tbl %&gt;% select(sim_number, row_id)

t &lt;- sim_outcomes_tbl %&gt;%
  select(sim_number, variable, row_id, int_sd, oper_sd, part_sd, repeatab_sd, st_dev_estimate) %&gt;%
  pivot_longer(cols = c(int_sd, oper_sd, part_sd, repeatab_sd)) %&gt;%
  right_join(sim_tbl) %&gt;%
  group_by(variable, name, value, row_id) %&gt;%
  count() %&gt;%
  ungroup() %&gt;%
  mutate(variable = case_when(
    name == &quot;int_sd&quot; ~ &quot;part:operator&quot;,
    name == &quot;oper_sd&quot; ~ &quot;operator&quot;,
    name == &quot;part_sd&quot; ~ &quot;part&quot;,
    TRUE ~ &quot;Residual&quot;
  )) %&gt;%
  right_join(sim_setup_tbl)

t %&gt;%
  head(10) %&gt;%
  select(variable, value, row_id, n_sims, n_part, n_oper, n_meas, int_sd, oper_sd, part_sd, repeatab_sd, tol_pct_true) %&gt;%
  kable(align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">variable</th>
<th align="center">value</th>
<th align="center">row_id</th>
<th align="center">n_sims</th>
<th align="center">n_part</th>
<th align="center">n_oper</th>
<th align="center">n_meas</th>
<th align="center">int_sd</th>
<th align="center">oper_sd</th>
<th align="center">part_sd</th>
<th align="center">repeatab_sd</th>
<th align="center">tol_pct_true</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">part:operator</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr class="even">
<td align="center">operator</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr class="odd">
<td align="center">part</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr class="even">
<td align="center">Residual</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr class="odd">
<td align="center">part:operator</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr class="even">
<td align="center">operator</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr class="odd">
<td align="center">part</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr class="even">
<td align="center">Residual</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr class="odd">
<td align="center">part:operator</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr class="even">
<td align="center">operator</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">200</td>
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
</tbody>
</table>
<p>It would be cool to see all the data from all the simulations. Recall that the true values of sd for operator, part:operator interaction, and Residual were 1 and that part variation increased across the different sims. All tof this is plotted below, with the true values in red while the results of the simulation shown in black. It can be seen that the simulations group nicely around the true values and we can see the uncertainty.</p>
<pre class="r"><code>sim_outcomes_tbl %&gt;%
  ggplot(aes(x = part_sd, y = st_dev_estimate)) +
  geom_point(size = .4) +
  geom_point(data = t, aes(x = part_sd, y = value), color = &quot;firebrick&quot;) +
  facet_wrap(~variable, scales = &quot;free&quot;) +
  labs(
    title = &quot;Simulation Results Across a Range of Possible Part Standard Deviations&quot;,
    subtitle = &quot;Gage R&amp;R with n=10 parts, n=3 operators, n=2 measurements&quot;,
    x = &quot;True Part Standard Deviation&quot;,
    y = &quot;Estimate of Standard Deviation&quot;,
    caption = &quot;red points mark true value of standard deviation for the effect&quot;
  )</code></pre>
<p><img src="/post/2020-09-09-simulation-with-a-random-effects-model-gage-r-r-as-a-case-study_files/figure-html/unnamed-chunk-22-1.png" width="100%" height="500px" /> Let's see how the estimated percent tolerance lines up with the true values from the population. This tbl calculates the percent tol across all the simulations.</p>
<pre class="r"><code>tol_outcomes_tbl &lt;- sim_outcomes_tbl %&gt;%
  filter(variable != &quot;part&quot;) %&gt;%
  group_by(sim_number, row_id) %&gt;%
  summarize(grr_variance_est = sum(variance_estimate)) %&gt;%
  right_join(sim_setup_tbl) %&gt;%
  rowwise() %&gt;%
  mutate(est_tol_pct = (grr_variance_est) / (part_sd)) %&gt;%
  select(n_part, n_oper, n_meas, int_sd, oper_sd, part_sd, tol_pct_true, est_tol_pct, everything())

tol_outcomes_tbl %&gt;%
  select(n_part, n_oper, n_meas, int_sd, oper_sd, part_sd, tol_pct_true, est_tol_pct, sim_number, row_id) %&gt;%
  head(10) %&gt;%
  kable(align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">n_part</th>
<th align="center">n_oper</th>
<th align="center">n_meas</th>
<th align="center">int_sd</th>
<th align="center">oper_sd</th>
<th align="center">part_sd</th>
<th align="center">tol_pct_true</th>
<th align="center">est_tol_pct</th>
<th align="center">sim_number</th>
<th align="center">row_id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1.723929</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">2.447401</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">5.098323</td>
<td align="center">3</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1.882222</td>
<td align="center">4</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1.702724</td>
<td align="center">5</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">2.381758</td>
<td align="center">6</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1.619832</td>
<td align="center">7</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">2.986048</td>
<td align="center">8</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">2.440299</td>
<td align="center">9</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">10</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">2.441025</td>
<td align="center">10</td>
<td align="center">1</td>
</tr>
</tbody>
</table>
<p>This summary tbl captures the mean from simulations conducted at each level.</p>
<pre class="r"><code>tol_est_tbl &lt;- tol_outcomes_tbl %&gt;%
  group_by(row_id, part_var) %&gt;%
  summarize(mean_est_tol_pct = mean(est_tol_pct))

tol_est_tbl %&gt;% kable(align = &quot;c&quot;)</code></pre>
<table>
<thead>
<tr class="header">
<th align="center">row_id</th>
<th align="center">part_var</th>
<th align="center">mean_est_tol_pct</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2.9902181</td>
</tr>
<tr class="even">
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2.1352549</td>
</tr>
<tr class="odd">
<td align="center">3</td>
<td align="center">4</td>
<td align="center">1.5002527</td>
</tr>
<tr class="even">
<td align="center">4</td>
<td align="center">8</td>
<td align="center">1.0354094</td>
</tr>
<tr class="odd">
<td align="center">5</td>
<td align="center">16</td>
<td align="center">0.7362949</td>
</tr>
<tr class="even">
<td align="center">6</td>
<td align="center">32</td>
<td align="center">0.5330749</td>
</tr>
<tr class="odd">
<td align="center">7</td>
<td align="center">64</td>
<td align="center">0.3708208</td>
</tr>
<tr class="even">
<td align="center">8</td>
<td align="center">128</td>
<td align="center">0.2657111</td>
</tr>
<tr class="odd">
<td align="center">9</td>
<td align="center">256</td>
<td align="center">0.1880981</td>
</tr>
<tr class="even">
<td align="center">10</td>
<td align="center">512</td>
<td align="center">0.1372343</td>
</tr>
<tr class="odd">
<td align="center">11</td>
<td align="center">1024</td>
<td align="center">0.0937739</td>
</tr>
</tbody>
</table>
<p>Visualize the mean from the simulations vs. the true tol percent:</p>
<pre class="r"><code>tol_outcomes_tbl %&gt;%
  ggplot(aes(x = part_var, y = est_tol_pct)) +
  #  geom_point(size = .5) +
  geom_point(aes(x = part_var, y = tol_pct_true), size = 3, color = &quot;limegreen&quot;, position = position_nudge(2), alpha = .85) +
  geom_line(aes(x = part_var, y = tol_pct_true), color = &quot;limegreen&quot;) +
  geom_point(data = tol_est_tbl, aes(x = part_var, y = mean_est_tol_pct), size = 3, color = &quot;firebrick&quot;, position = position_nudge(-2), alpha = .85) +
  geom_hline(yintercept = .3, lty = 2, color = &quot;#2c3e50&quot;) +
  scale_y_continuous(labels = scales::percent) +
  labs(
    title = &quot;Comparison of Simulation Results to True: Tolerance Percent Metric&quot;,
    subtitle = &quot;Green is true population, Red is mean of simulation estimates&quot;,
    x = &quot;Part Variance&quot;,
    y = &quot;Tolerance Percent&quot;,
    caption = &quot;dotted line shows 30% acceptance limit&quot;
  )</code></pre>
<p><img src="/post/2020-09-09-simulation-with-a-random-effects-model-gage-r-r-as-a-case-study_files/figure-html/unnamed-chunk-25-1.png" width="100%" height="500px" /></p>
<p>Very nice agreement between the simulations and the true population values. But the above plot just shows the mean. How much uncertainty is expected across experiments at the same settings? Here I show a subset of data below the 100% level (just to keep the plot a little less messy).</p>
<pre class="r"><code>tol_outcomes_tbl %&gt;%
  ggplot(aes(x = part_var, y = est_tol_pct)) +
  geom_point(size = .5) +
  geom_point(aes(x = part_var, y = tol_pct_true), size = 3, color = &quot;limegreen&quot;, position = position_nudge(2), alpha = .85) +
  geom_line(aes(x = part_var, y = tol_pct_true), color = &quot;limegreen&quot;) +
  geom_point(data = tol_est_tbl, aes(x = part_var, y = mean_est_tol_pct), size = 3, color = &quot;firebrick&quot;, position = position_nudge(-2), alpha = .85) +
  geom_hline(yintercept = .3, lty = 2) +
  scale_y_continuous(
    labels = scales::percent,
    expand = expansion(),
    limits = c(0, 1)
  ) +
  labs(
    title = &quot;Comparison of Simulation Results to True: Tolerance Percent Metric&quot;,
    subtitle = &quot;Green is true population, Red is mean of simulation estimates, Black is intividual estimates&quot;,
    x = &quot;Part Variance&quot;,
    y = &quot;Tolerance Percent&quot;,
    caption = &quot;dotted line shows 30% acceptance limit&quot;
  )</code></pre>
<p><img src="/post/2020-09-09-simulation-with-a-random-effects-model-gage-r-r-as-a-case-study_files/figure-html/unnamed-chunk-26-1.png" width="100%" height="500px" /></p>
<p>Pretty interesting. There is quite a bit of uncertainty here and there are quite a few cases where individual simulations fail just due to chance. The probability of this happening is worst when the part variance is around 100-400% of the operator and repeatability sd.</p>
<p>From this point one could start tweaking any values of interest to see how the uncertainty of the performance metric is affected. For example, you might look at the optimal number of operators or replicates to give the best chance of passing when the true population value would pass. Pretty powerful stuff!</p>
<p>In this post I attempted to show how a Gage R&amp;R test can be modeled with random effects model. A simulation was constructed using the extracted design matrix Z and a vector of random effects. The simulation was then scaled to see how well the mean of the simulations converge with the true population parameter and the uncertainty was visualized by plotting individual estimates on the same grid. Good luck and I hope this post is useful!</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://lindeloev.github.io/tests-as-linear/" class="uri">https://lindeloev.github.io/tests-as-linear/</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Assessment of the Adequacy of Gauge Repeatability and Reproducibility Study Using a Monte Carlo Simulation, <a href="https://www.hindawi.com/journals/mpe/2017/7237486/" class="uri">https://www.hindawi.com/journals/mpe/2017/7237486/</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Conflicting definitions of random/mixed effects <a href="https://statmodeling.stat.columbia.edu/2005/01/25/why_i_dont_use/" class="uri">https://statmodeling.stat.columbia.edu/2005/01/25/why_i_dont_use/</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Some simulations are motivated/recreated/expanded from the excellent paper by Ha et al, <a href="https://doi.org/10.1155/2017/7237486" class="uri">https://doi.org/10.1155/2017/7237486</a><a href="#fnref4">↩</a></p></li>
<li id="fn5"><p><a href="https://debruine.github.io/tutorials/sim-lmer.html" class="uri">https://debruine.github.io/tutorials/sim-lmer.html</a><a href="#fnref5">↩</a></p></li>
<li id="fn6"><p><a href="https://aosmith.rbind.io/2018/04/23/simulate-simulate-part-2/" class="uri">https://aosmith.rbind.io/2018/04/23/simulate-simulate-part-2/</a><a href="#fnref6">↩</a></p></li>
<li id="fn7"><p><a href="https://stats.stackexchange.com/questions/483509/simulating-observations-for-a-2-way-anova-in-r-w-mixed-effects-model-and-reco" class="uri">https://stats.stackexchange.com/questions/483509/simulating-observations-for-a-2-way-anova-in-r-w-mixed-effects-model-and-reco</a><a href="#fnref7">↩</a></p></li>
</ol>
</div>
